<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <title>3D Model Viewer (STL/3MF)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #eeeeee; }
        canvas { display: block; }
        #file-input-container {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            font-family: sans-serif;
        }
        #fileInput {
            padding: 8px 12px;
            border: 1px solid #ccc;
            border-radius: 4px;
            cursor: pointer;
        }
    </style>
</head>
<body>

    <div id="file-input-container">
        <input type="file" id="fileInput" accept=".stl, .3mf">
    </div>

    <script type="module">
        
        // ** DEZE LINKS ZIJN NU GECORRIGEERD EN STABIEL VOOR CDN **
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js';
        import { STLLoader } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/STLLoader.js';
        import { ThreeMFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/ThreeMFLoader.js';

        let scene, camera, renderer, controls;
        let model;
        const fileInput = document.getElementById('fileInput');

        init();

        // --- Event Listener voor de Uploadknop ---
        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                readFile(file);
            }
        });

        function init() {
            // --- SCÈNE & CAMERA ---
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xeeeeee);
            
            // Camera breed bereik
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 50000); 
            camera.position.z = 50;

            // --- RENDERER ---
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // --- CONTROLS ---
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.25;

            // --- LICHT ---
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1).normalize();
            scene.add(directionalLight);

            window.addEventListener('resize', onWindowResize, false);
            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        /**
         * Leest het geselecteerde lokale bestand in met de FileReader API.
         */
        function readFile(file) {
            const reader = new FileReader();
            const fileName = file.name;
            const extension = fileName.split('.').pop().toLowerCase();

            // Lees het bestand als een ArrayBuffer (ruwe binaire data)
            reader.readAsArrayBuffer(file);

            reader.onload = function(event) {
                const buffer = event.target.result;
                loadModel(buffer, extension);
            };

            reader.onerror = function() {
                console.error("Fout bij het lezen van het bestand.");
            };
        }

        /**
         * Laadt het model uit de ArrayBuffer in de 3D-scène en stelt de camera in.
         */
        function loadModel(buffer, extension) {
            // Verwijder het vorige model
            if (model) {
                scene.remove(model);
                model.geometry?.dispose();
                model.material?.dispose();
            }

            let newModel = null;

            if (extension === 'stl') {
                const stlLoader = new STLLoader(); 
                const geometry = stlLoader.parse(buffer);
                
                // --- DIAGNOSE: CONTROLEER GEOMETRIE DATA ---
                if (!geometry.attributes.position || geometry.attributes.position.count === 0) {
                    console.error("Geometrie is leeg of ongeldig. Controleer uw STL-bestand.");
                    return;
                }
                console.log('Model geladen. Aantal vertices:', geometry.attributes.position.count); 
                // --- EINDE DIAGNOSE ---

                const material = new THREE.MeshPhongMaterial({ 
                    color: 0xaaaaaa, 
                    specular: 0x111111, 
                    shininess: 200,
                    wireframe: true // Forceer wireframe voor zichtbaarheid
                });
                newModel = new THREE.Mesh(geometry, material);

            } else if (extension === '3mf') {
                const threeMFLoader = new ThreeMFLoader(); 
                newModel = threeMFLoader.parse(buffer); 
                console.log('3MF model succesvol geladen!');

            } else {
                console.error('Bestandsformaat niet ondersteund: ' + extension);
                return;
            }

            if (newModel) {
                model = newModel;
                scene.add(model);
                
                // Centreer en zoom de camera
                const boundingBox = new THREE.Box3().setFromObject(model);
                const center = boundingBox.getCenter(new THREE.Vector3());
                const size = boundingBox.getSize(new THREE.Vector3());
                
                controls.target.copy(center);
                const maxDim = Math.max(size.x, size.y, size.z);
                const fov = camera.fov * (Math.PI / 180);
                let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2)) * 1.5; 
                
                // Stel positie in
                if (maxDim > 0) {
                   camera.position.z = center.z + cameraZ;
                   camera.position.x = center.x;
                   camera.position.y = center.y;
                } else {
                   camera.position.set(0, 0, 100);
                }
                
                camera.updateProjectionMatrix();
                controls.update();
            }
        }
    </script>
</body>
</html>