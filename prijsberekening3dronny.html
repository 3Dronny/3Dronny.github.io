<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Print Kosten Calculator | 3DRonny</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <style>
        /* [Alle CSS blijft hetzelfde] */
    </style>
</head>
<body>
    <div class="container">
        <!-- [Alle HTML blijft hetzelfde] -->
    </div>

    <script>
        // Materiaal dichtheden in g/cm³ - GECORRIGEERD met factor 1.749
        const materialDensities = {
            'pla': 1.24 * 1.749,    // 74.9% zwaarder
            'petg': 1.27 * 1.749,   // 74.9% zwaarder
            'abs': 1.05 * 1.749,    // 74.9% zwaarder
            'tpu': 1.21 * 1.749,    // 74.9% zwaarder
            'nylon': 1.14 * 1.749,  // 74.9% zwaarder
            'resin': 1.12 * 1.749   // 74.9% zwaarder
        };

        // [De rest van de JavaScript code blijft exact hetzelfde]
        // Alleen de dichtheden zijn aangepast

        // Eenvoudige STL Parser voor zowel ASCII als Binary STL
        class SimpleSTLParser {
            static parseSTL(arrayBuffer) {
                const dataView = new DataView(arrayBuffer);
                
                // Check if it's ASCII STL
                const header = new TextDecoder().decode(arrayBuffer.slice(0, 80));
                const isASCII = header.toLowerCase().includes('solid') && 
                               !header.toLowerCase().includes('endsolid');
                
                if (isASCII) {
                    return this.parseASCIISTL(arrayBuffer);
                } else {
                    return this.parseBinarySTL(arrayBuffer);
                }
            }
            
            static parseASCIISTL(arrayBuffer) {
                const text = new TextDecoder().decode(arrayBuffer);
                const lines = text.split('\n');
                const vertices = [];
                const faces = [];
                let currentFace = [];
                
                for (const line of lines) {
                    const trimmed = line.trim();
                    if (trimmed.startsWith('vertex')) {
                        const parts = trimmed.split(/\s+/);
                        if (parts.length >= 4) {
                            const x = parseFloat(parts[1]);
                            const y = parseFloat(parts[2]);
                            const z = parseFloat(parts[3]);
                            currentFace.push(vertices.length);
                            vertices.push(x, y, z);
                        }
                    } else if (trimmed.startsWith('endloop')) {
                        if (currentFace.length === 3) {
                            faces.push(...currentFace);
                        }
                        currentFace = [];
                    }
                }
                
                return { vertices: new Float32Array(vertices), faces: new Uint32Array(faces) };
            }
            
            static parseBinarySTL(arrayBuffer) {
                const dataView = new DataView(arrayBuffer);
                const faces = dataView.getUint32(80, true);
                const vertices = [];
                const facesArray = [];
                
                let offset = 84;
                for (let i = 0; i < faces; i++) {
                    // Skip normal
                    offset += 12;
                    
                    // Read vertices
                    for (let j = 0; j < 3; j++) {
                        const x = dataView.getFloat32(offset, true);
                        const y = dataView.getFloat32(offset + 4, true);
                        const z = dataView.getFloat32(offset + 8, true);
                        vertices.push(x, y, z);
                        facesArray.push(vertices.length / 3 - 1);
                        offset += 12;
                    }
                    
                    // Skip attribute byte count
                    offset += 2;
                }
                
                return { vertices: new Float32Array(vertices), faces: new Uint32Array(facesArray) };
            }
        }

        // NIEUW: Nauwkeurige volume berekening voor STL
        function calculateSTLVolume(geometry) {
            const positions = geometry.attributes.position.array;
            const indices = geometry.index ? geometry.index.array : null;
            
            let volume = 0;
            
            if (indices) {
                // Gebruik indices voor geïndexeerde geometry
                for (let i = 0; i < indices.length; i += 3) {
                    const i1 = indices[i] * 3;
                    const i2 = indices[i + 1] * 3;
                    const i3 = indices[i + 2] * 3;
                    
                    const v1 = new THREE.Vector3(positions[i1], positions[i1 + 1], positions[i1 + 2]);
                    const v2 = new THREE.Vector3(positions[i2], positions[i2 + 1], positions[i2 + 2]);
                    const v3 = new THREE.Vector3(positions[i3], positions[i3 + 1], positions[i3 + 2]);
                    
                    // Volume van tetrahedron (1/6 van de scalar triple product)
                    volume += v1.dot(v2.cross(v3)) / 6;
                }
            } else {
                // Niet-geïndexeerde geometry
                for (let i = 0; i < positions.length; i += 9) {
                    const v1 = new THREE.Vector3(positions[i], positions[i + 1], positions[i + 2]);
                    const v2 = new THREE.Vector3(positions[i + 3], positions[i + 4], positions[i + 5]);
                    const v3 = new THREE.Vector3(positions[i + 6], positions[i + 7], positions[i + 8]);
                    
                    volume += v1.dot(v2.cross(v3)) / 6;
                }
            }
            
            // STL gebruikt mm, dus volume is in mm³
            // Converteren naar cm³ (1 cm³ = 1000 mm³)
            return Math.abs(volume) / 1000;
        }

        // Update het infill percentage in de weergave
        function updateInfillDisplay() {
            const infillValue = document.getElementById('infill').value;
            document.getElementById('current-infill').textContent = infillValue;
        }

        // Globale variabelen
        let scene, camera, renderer, controls, model;
        let stlFile = null;
        let isViewerInitialized = false;
        
        // Initialisatie van de 3D viewer
        function initViewer() {
            if (isViewerInitialized) return;
            
            const container = document.getElementById('model-viewer');
            
            // Verberg het "geen bestand" bericht
            document.getElementById('no-file-message').style.display = 'none';
            
            // Scene met WITTE achtergrond
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);
            
            // Camera
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);
            camera.lookAt(0, 0, 0);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                preserveDrawingBuffer: true
            });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setClearColor(0xffffff, 1);
            container.appendChild(renderer.domElement);
            
            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.25;
            controls.minDistance = 1;
            controls.maxDistance = 50;
            
            // Licht - alleen ambient light voor zachte verlichting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            
            // Directional light voor betere diepte
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(5, 10, 5);
            scene.add(directionalLight);
            
            // Animatie
            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }
            animate();
            
            // Responsive
            window.addEventListener('resize', function() {
                if (container.clientWidth > 0 && container.clientHeight > 0) {
                    camera.aspect = container.clientWidth / container.clientHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(container.clientWidth, container.clientHeight);
                }
            });
            
            isViewerInitialized = true;
        }
        
        // Automatische oriëntatie functie met 180 graden rotatie
        function autoOrientModel() {
            if (!model) return;
            
            // Reset rotatie
            model.rotation.set(0, 0, 0);
            
            // Bereken bounding box
            const box = new THREE.Box3().setFromObject(model);
            const size = new THREE.Vector3();
            box.getSize(size);
            
            // Vind de langste as en zet die verticaal
            const maxAxis = Math.max(size.x, size.y, size.z);
            
            if (maxAxis === size.x) {
                // Draai 90 graden rond Z-as als X de langste is
                model.rotation.z = Math.PI / 2;
            } else if (maxAxis === size.z) {
                // Draai 90 graden rond X-as als Z de langste is
                model.rotation.x = Math.PI / 2;
            }
            // Als Y de langste is, blijft het model zoals het is
            
            // NIEUW: Draai het model 180 graden rond de Y-as
            model.rotation.y += Math.PI;
            
            // Centreer het model op de oorsprong
            const center = new THREE.Vector3();
            box.getCenter(center);
            model.position.sub(center);
            
            // Zet het model op de "vloer" (y = 0)
            box.setFromObject(model);
            const minY = box.min.y;
            model.position.y -= minY;
            
            // Update controls
            controls.update();
        }
        
        // STL-bestand laden
        function loadSTL(file) {
            if (!file) {
                showError('Geen bestand geselecteerd.');
                return;
            }
            
            if (!file.name.toLowerCase().endsWith('.stl')) {
                showError('Alleen STL-bestanden worden ondersteund.');
                return;
            }
            
            // Toon laadindicator
            document.getElementById('loading').style.display = 'block';
            hideError();
            hideSuccess();
            
            const reader = new FileReader();
            
            reader.onload = function(event) {
                try {
                    // Gebruik onze eigen STL parser
                    const stlData = SimpleSTLParser.parseSTL(event.target.result);
                    
                    // Initialiseer viewer als dat nog niet gebeurd is
                    if (!isViewerInitialized) {
                        initViewer();
                    }
                    
                    // Verwijder vorig model
                    if (model) {
                        scene.remove(model);
                    }
                    
                    // Creëer geometry
                    const geometry = new THREE.BufferGeometry();
                    geometry.setAttribute('position', new THREE.BufferAttribute(stlData.vertices, 3));
                    geometry.setIndex(new THREE.BufferAttribute(stlData.faces, 1));
                    geometry.computeVertexNormals();
                    
                    // Materiaal
                    const material = new THREE.MeshPhongMaterial({ 
                        color: 0x6a11cb,
                        specular: 0x111111, 
                        shininess: 100,
                        flatShading: false
                    });
                    
                    // Mesh
                    model = new THREE.Mesh(geometry, material);
                    
                    // NIEUW: Bereken optimale schaal met 20% vergroting
                    geometry.computeBoundingBox();
                    const size = new THREE.Vector3();
                    geometry.boundingBox.getSize(size);
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scale = (8 / maxDim) * 1.2; // 20% groter
                    
                    model.scale.set(scale, scale, scale);
                    
                    scene.add(model);
                    
                    // Automatische oriëntatie met 180 graden rotatie
                    autoOrientModel();
                    
                    // NIEUW: Verbeterde camera positioning voor betere centrering
                    const box = new THREE.Box3().setFromObject(model);
                    const center = new THREE.Vector3();
                    box.getCenter(center);
                    
                    const newSize = new THREE.Vector3();
                    box.getSize(newSize);
                    const maxSize = Math.max(newSize.x, newSize.y, newSize.z);
                    
                    // Camera position based on model size for better framing
                    const cameraDistance = maxSize * 2;
                    camera.position.set(cameraDistance, cameraDistance * 0.7, cameraDistance);
                    camera.lookAt(center);
                    controls.target.copy(center);
                    controls.update();
                    
                    // Update bestandsinformatie met CORRECTE volume berekening
                    updateFileInfo(file, geometry);
                    
                    // Verberg laadindicator en toon succes
                    document.getElementById('loading').style.display = 'none';
                    showSuccess('Bestand succesvol geladen en weergegeven!');
                    
                } catch (error) {
                    console.error('Fout bij het laden van STL-bestand:', error);
                    showError('Fout bij laden STL-bestand: ' + error.message);
                    document.getElementById('loading').style.display = 'none';
                }
            };
            
            reader.onerror = function() {
                showError('Fout bij het lezen van het bestand.');
                document.getElementById('loading').style.display = 'none';
            };
            
            reader.readAsArrayBuffer(file);
        }
        
        // Bestandsinformatie bijwerken met gewichtsberekening
        function updateFileInfo(file, geometry) {
            document.getElementById('file-name').textContent = file.name;
            document.getElementById('file-size').textContent = formatFileSize(file.size);
            
            // Bereken afmetingen (in mm)
            geometry.computeBoundingBox();
            const size = new THREE.Vector3();
            geometry.boundingBox.getSize(size);
            
            // NIEUW: Gebruik nauwkeurige volume berekening
            const volume = calculateSTLVolume(geometry);
            
            document.getElementById('file-volume').textContent = volume.toFixed(2) + ' cm³';
            document.getElementById('file-dimensions').textContent = 
                `${size.x.toFixed(1)} × ${size.y.toFixed(1)} × ${size.z.toFixed(1)} mm`;
            
            // NIEUW: Bereken en toon gewicht met 74.9% correctie bij 30% infill
            const material = document.getElementById('material').value;
            const density = materialDensities[material];
            const weight = volume * density * 0.30; // 30% infill
            document.getElementById('file-weight').textContent = weight.toFixed(1) + ' g';
            
            // Sla modelgegevens op voor berekening
            stlFile = {
                file: file,
                volume: volume,
                dimensions: size,
                weight: weight
            };
            
            // Bereken automatisch de prijs
            calculatePrice();
        }
        
        // Bestandsgrootte formatteren
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        // Foutmelding tonen
        function showError(message) {
            const errorElement = document.getElementById('error-message');
            errorElement.textContent = message;
            errorElement.style.display = 'block';
        }
        
        // Foutmelding verbergen
        function hideError() {
            document.getElementById('error-message').style.display = 'none';
        }
        
        // Succesmelding tonen
        function showSuccess(message) {
            const successElement = document.getElementById('success-message');
            successElement.textContent = message;
            successElement.style.display = 'block';
        }
        
        // Succesmelding verbergen
        function hideSuccess() {
            document.getElementById('success-message').style.display = 'none';
        }
        
        // Prijs berekenen met gewichtsberekening
        function calculatePrice() {
            if (!stlFile) {
                document.getElementById('material-cost').textContent = '€0.00';
                document.getElementById('print-time').textContent = '0 uur';
                document.getElementById('machine-cost').textContent = '€0.00';
                document.getElementById('print-weight').textContent = '0 g';
                document.getElementById('total-price').textContent = '€5.00';
                return;
            }
            
            const materialPrices = {
                'pla': 0.05, 'petg': 0.07, 'abs': 0.06, 'tpu': 0.09, 'nylon': 0.11, 'resin': 0.15
            };
            
            const material = document.getElementById('material').value;
            const materialPrice = materialPrices[material];
            const density = materialDensities[material];
            const infill = parseInt(document.getElementById('infill').value) / 100;
            const volume = stlFile.volume;
            
            // Update infill display
            updateInfillDisplay();
            
            // NIEUW: Bereken gewicht met infill en 74.9% correctie
            const weight = volume * infill * density;
            document.getElementById('print-weight').textContent = weight.toFixed(1) + ' g';
            
            const materialCost = volume * infill * materialPrice;
            
            const qualityMultipliers = {
                'draft': 0.7, 'standard': 1, 'high': 1.5, 'ultra': 2.5
            };
            
            const quality = document.getElementById('quality').value;
            const qualityMultiplier = qualityMultipliers[quality];
            const printTime = volume * 0.05 * qualityMultiplier;
            const machineCost = printTime * 2;
            const setupCost = 5.00;
            const totalCost = materialCost + machineCost + setupCost;
            
            document.getElementById('material-cost').textContent = '€' + materialCost.toFixed(2);
            document.getElementById('print-time').textContent = printTime.toFixed(1) + ' uur';
            document.getElementById('machine-cost').textContent = '€' + machineCost.toFixed(2);
            document.getElementById('total-price').textContent = '€' + totalCost.toFixed(2);
        }
        
        // Event listeners
        document.addEventListener('DOMContentLoaded', function() {
            // Upload knop
            document.getElementById('upload-btn').addEventListener('click', function() {
                document.getElementById('file-input').click();
            });
            
            // Bestand input
            document.getElementById('file-input').addEventListener('change', function(e) {
                if (e.target.files.length > 0) {
                    loadSTL(e.target.files[0]);
                }
            });
            
            // Drag and drop
            const dropArea = document.getElementById('drop-area');
            
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropArea.addEventListener(eventName, preventDefaults, false);
            });
            
            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }
            
            ['dragenter', 'dragover'].forEach(eventName => {
                dropArea.addEventListener(eventName, highlight, false);
            });
            
            ['dragleave', 'drop'].forEach(eventName => {
                dropArea.addEventListener(eventName, unhighlight, false);
            });
            
            function highlight() {
                dropArea.classList.add('dragover');
            }
            
            function unhighlight() {
                dropArea.classList.remove('dragover');
            }
            
            dropArea.addEventListener('drop', function(e) {
                const dt = e.dataTransfer;
                const files = dt.files;
                
                if (files.length > 0) {
                    loadSTL(files[0]);
                }
            });
            
            // Viewer controls
            document.getElementById('reset-view').addEventListener('click', function() {
                if (controls) {
                    controls.reset();
                }
            });
            
            document.getElementById('toggle-wireframe').addEventListener('click', function() {
                if (model) {
                    model.material.wireframe = !model.material.wireframe;
                }
            });
            
            document.getElementById('auto-orient').addEventListener('click', function() {
                autoOrientModel();
            });
            
            // Formulier wijzigingen
            document.getElementById('material').addEventListener('change', function() {
                if (stlFile) {
                    // Update gewicht wanneer materiaal verandert
                    const material = this.value;
                    const density = materialDensities[material];
                    const weight = stlFile.volume * density * 0.30; // 30% infill
                    document.getElementById('file-weight').textContent = weight.toFixed(1) + ' g';
                }
                calculatePrice();
            });
            
            document.getElementById('quality').addEventListener('change', calculatePrice);
            document.getElementById('infill').addEventListener('change', function() {
                updateInfillDisplay();
                calculatePrice();
            });
            
            // Bereken initiële prijs
            updateInfillDisplay();
            calculatePrice();
        });
    </script>
</body>
</html>