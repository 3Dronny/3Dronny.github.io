<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Professionele 3D Print Calculator | 3DRonny</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script> 
    
    <style>
        /* CSS Variabelen voor de groene accentkleur */
        :root {
            --accent-color: #10b981; /* Emerald Green */
            --accent-hover: #059669;
        }

        /* Basis Donker Thema */
        body {
            background-color: #121212; 
            color: #e0e0e0; 
            font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
        }
        
        /* Viewer en input veld stijlen */
        #viewer-container {
            width: 100%;
            height: 600px;
            background-color: #1e1e1e; 
            border-radius: 12px;
            overflow: hidden;
            position: relative;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
        }

        .accent-text {
            color: var(--accent-color);
        }

        .card-bg {
            background-color: #1e1e1e;
            border: 1px solid #333;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        .input-field {
            background-color: #2a2a2a;
            border: 1px solid #444;
            color: white;
            transition: border-color 0.2s;
        }
        .input-field:focus {
            border-color: var(--accent-color);
            box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.5);
        }

        .btn-primary {
            background-color: var(--accent-color);
            color: #121212;
            transition: background-color 0.2s;
        }
        .btn-primary:hover {
            background-color: var(--accent-hover);
            box-shadow: 0 4px 6px rgba(16, 185, 129, 0.3);
        }
    </style>
</head>
<body class="p-8">
    <div class="max-w-7xl mx-auto">
        
        <header class="text-center mb-12">
            <h1 class="text-5xl font-extrabold text-white mb-3 tracking-tight">
                3DRonny <span class="accent-text">Pricing Engine</span>
            </h1>
            <p class="text-gray-400 text-xl">Upload, Visualiseer en Bereken direct uw 3D Print Kosten.</p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-5 gap-10">
            
            <div class="lg:col-span-3">
                <h2 class="text-3xl font-semibold mb-4 text-white">
                    <i class="fas fa-cube mr-3 accent-text"></i>3D Model Viewer
                </h2>
                
                <div id="viewer-container">
                    <p id="viewer-placeholder" class="absolute inset-0 flex items-center justify-center text-gray-500">
                        Upload een STL- of 3MF-bestand om de 3D-viewer te starten.
                    </p>
                    <div id="loading-indicator" class="loading-overlay hidden">
                        <i class="fas fa-spinner fa-spin mr-3"></i> Model laden...
                    </div>
                </div>
                
                <div class="mt-4 flex flex-col sm:flex-row space-y-3 sm:space-y-0 sm:space-x-3">
                    <input type="file" id="file-upload" accept=".stl,.3mf" class="input-field p-3 rounded-lg flex-grow cursor-pointer" aria-label="Upload 3D Model Bestand">
                    <button id="reset-view-btn" class="btn-primary p-3 rounded-lg font-semibold whitespace-nowrap">
                        <i class="fas fa-sync-alt mr-2"></i>Reset View
                    </button>
                </div>
                <p class="text-sm text-gray-500 mt-2">Ondersteunde formaten: **STL** en **3MF**. Gebruik de muis om te draaien, zoomen en pannen.</p>
            </div>

            <div class="lg:col-span-2">
                <h2 class="text-3xl font-semibold mb-4 text-white">
                    <i class="fas fa-calculator mr-3 accent-text"></i>Kostenberekening
                </h2>
                
                <form id="price-calculator" class="space-y-6 card-bg p-8 rounded-xl">
                    
                    <div>
                        <label for="printtijd" class="block mb-2 font-medium text-gray-300">
                            <i class="fas fa-clock mr-2 accent-text"></i>Printduur (uren)
                        </label>
                        <input type="number" id="printtijd" step="0.1" min="0" value="5.0"
                               class="w-full input-field p-3 rounded-lg" placeholder="5.0" required>
                    </div>
                    
                    <div>
                        <label for="gewicht" class="block mb-2 font-medium text-gray-300">
                            <i class="fas fa-weight-hanging mr-2 accent-text"></i>Gewicht (gram)
                        </label>
                        <input type="number" id="gewicht" step="1" min="1" value="100"
                               class="w-full input-field p-3 rounded-lg" placeholder="100" required>
                    </div>

                    <div>
                        <label for="vulling" class="block mb-2 font-medium text-gray-300">
                            <i class="fas fa-fill-drip mr-2 accent-text"></i>Vulling / Infill (%)
                        </label>
                        <input type="number" id="vulling" step="5" min="0" max="100" value="20"
                               class="w-full input-field p-3 rounded-lg" placeholder="20" required>
                    </div>
                    
                    <div>
                        <label for="vaste-kosten" class="block mb-2 font-medium text-gray-300">
                            <i class="fas fa-euro-sign mr-2 accent-text"></i>Opstart/Vaste kosten (€)
                        </label>
                        <input type="number" id="vaste-kosten" step="0.50" min="0" value="5.00"
                               class="w-full input-field p-3 rounded-lg" placeholder="5.00" required>
                        <p class="text-xs text-gray-500 mt-1">Vaste kosten voor opstarten en afschrijving.</p>
                    </div>

                    <button type="submit" class="btn-primary w-full p-4 rounded-lg font-bold text-lg">
                        <i class="fas fa-cogs mr-2"></i>BEREKEN TOTALE PRIJS
                    </button>
                </form>

                <div id="resultaat-container" class="mt-8 card-bg p-8 rounded-xl border-l-4 border-l-[var(--accent-color)] shadow-xl hidden" role="status">
                    <h3 class="text-3xl font-bold mb-3 accent-text">Totale Geschatte Prijs:</h3>
                    <p class="text-5xl text-white font-extrabold" id="totaal-prijs">€ 0.00</p>
                    <p class="text-sm text-gray-500 mt-3">Gebaseerd op de ingevoerde parameters. De definitieve prijs kan variëren.</p>
                </div>
            </div>
        </div>
    </div>
    
    <script>
    // **BEGIN VAN INGEBOUWDE CODE**
    // Deze scripts bevatten de volledige code voor OrbitControls, STLLoader, JSZip en 3MFLoader.

// === Three.js OrbitControls r128 ===
( function () {

    const STATE = {
        NONE: - 1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_DOLLY_PAN: 4
    };
    const EPS = 0.000001;
    const lastPosition = new THREE.Vector3();
    const lastQuaternion = new THREE.Quaternion();
    const rotateStart = new THREE.Vector2();
    const rotateEnd = new THREE.Vector2();
    const rotateDelta = new THREE.Vector2();
    const panStart = new THREE.Vector2();
    const panEnd = new THREE.Vector2();
    const panDelta = new THREE.Vector2();
    const dollyStart = new THREE.Vector2();
    const dollyEnd = new THREE.Vector2();
    const dollyDelta = new THREE.Vector2();
    const dollyStart_1 = new THREE.Vector2();
    const dollyStart_2 = new THREE.Vector2();
    const dollyEnd_1 = new THREE.Vector2();
    const dollyEnd_2 = new THREE.Vector2();
    const dollyDelta_A = new THREE.Vector2();
    const dollyDelta_B = new THREE.Vector2();
    const pan = new THREE.Vector3();
    const tempVector = new THREE.Vector3();
    const offset = new THREE.Vector3();
    const quat = new THREE.Quaternion().setFromUnitVectors( new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ) );
    const quatInverse = quat.clone().invert();
    const spherical = new THREE.Spherical();
    const sphericalDelta = new THREE.Spherical();

    class OrbitControls extends THREE.EventDispatcher {

        constructor( object, domElement ) {

            super();

            this.object = object;
            this.domElement = domElement;
            this.enabled = true;
            this.target = new THREE.Vector3();
            this.minDistance = 0;
            this.maxDistance = Infinity;
            this.minZoom = 0;
            this.maxZoom = Infinity;
            this.minPolarAngle = 0; // radians
            this.maxPolarAngle = Math.PI; // radians
            this.minAzimuthAngle = - Infinity; // radians
            this.maxAzimuthAngle = Infinity; // radians
            this.enableDamping = false;
            this.dampingFactor = 0.05;
            this.enableZoom = true;
            this.zoomSpeed = 1.0;
            this.enableRotate = true;
            this.rotateSpeed = 1.0;
            this.enablePan = true;
            this.panSpeed = 1.0;
            this.screenSpacePanning = false; // if true, pan in screen space
            this.keyPanSpeed = 7.0; // pixels per key press
            this.autoRotate = false;
            this.autoRotateSpeed = 2.0; // 30 seconds per round when at 60fps for example
            this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };
            this.mouseButtons = { LEFT: THREE.MOUSE.LEFT, MIDDLE: THREE.MOUSE.MIDDLE, RIGHT: THREE.MOUSE.RIGHT };
            this.touches = { ONE: THREE.TOUCH.PAN, TWO: THREE.TOUCH.DOLLY_ROTATE };
            this.target0 = this.target.clone();
            this.position0 = this.object.position.clone();
            this.zoom0 = this.object.zoom;

            this._state = STATE.NONE;
            this._domElementKeyEvents = null;

            // the event listener variables are defined here
            this._pointerDownHandler = this.onPointerDown.bind( this );
            this._pointerMoveHandler = this.onPointerMove.bind( this );
            this._pointerUpHandler = this.onPointerUp.bind( this );
            this._contextMenuHandler = this.onContextMenu.bind( this );
            this._wheelHandler = this.onMouseWheel.bind( this );

            this.domElement.addEventListener( 'contextmenu', this._contextMenuHandler );
            this.domElement.addEventListener( 'pointerdown', this._pointerDownHandler );
            this.domElement.addEventListener( 'wheel', this._wheelHandler );

            // the three private methods
            this._rotateLeft = this.rotateLeft.bind( this );
            this._rotateUp = this.rotateUp.bind( this );
            this._panLeft = this.panLeft.bind( this );
            this._panUp = this.panUp.bind( this );
            this._dollyOut = this.dollyOut.bind( this );
            this._dollyIn = this.dollyIn.bind( this );

            // force an update at start
            this.update();

        }

        getPolarAngle() {

            return spherical.phi;

        }

        getAzimuthalAngle() {

            return spherical.theta;

        }

        setFromCamera( camera ) {

            this.object.position.copy( camera.position );
            this.object.quaternion.copy( camera.quaternion );

        }

        update() {

            const position = this.object.position;

            offset.copy( position ).sub( this.target );

            // rotate offset to "y-axis-is-up" space
            offset.applyQuaternion( quat );

            // angle from z-axis around y-axis
            spherical.setFromVector3( offset );

            if ( this.autoRotate && this._state === STATE.NONE ) {

                this.rotateLeft( this.getAutoRotationAngle() );

            }

            spherical.theta += sphericalDelta.theta;
            spherical.phi += sphericalDelta.phi;

            // restrict spherical.theta to be between desired limits
            let min = this.minAzimuthAngle;
            let max = this.maxAzimuthAngle;

            if ( isFinite( min ) && isFinite( max ) ) {

                if ( min < - Math.PI ) min += 2 * Math.PI;
                if ( max > Math.PI ) max -= 2 * Math.PI;

                if ( min < max ) {

                    spherical.theta = Math.max( min, Math.min( max, spherical.theta ) );

                } else {

                    spherical.theta = ( spherical.theta > max ) ? spherical.theta - 2 * Math.PI : spherical.theta;
                    spherical.theta = ( spherical.theta < min ) ? spherical.theta + 2 * Math.PI : spherical.theta;
                    spherical.theta = Math.max( min, Math.min( max, spherical.theta ) );

                }

            }

            // restrict spherical.phi to be between desired limits
            spherical.phi = Math.max( this.minPolarAngle, Math.min( this.maxPolarAngle, spherical.phi ) );

            spherical.makeSafe();

            spherical.radius *= dollyDelta.x;

            // restrict radius to be between desired limits
            spherical.radius = Math.max( this.minDistance, Math.min( this.maxDistance, spherical.radius ) );

            // move target to panned location
            this.target.add( pan );

            offset.setFromSpherical( spherical );

            // rotate offset back to "camera-up" space
            offset.applyQuaternion( quatInverse );

            position.copy( this.target ).add( offset );

            this.object.lookAt( this.target );

            if ( this.enableDamping === true ) {

                sphericalDelta.theta *= ( 1 - this.dampingFactor );
                sphericalDelta.phi *= ( 1 - this.dampingFactor );

                pan.multiplyScalar( 1 - this.dampingFactor );

            } else {

                sphericalDelta.set( 0, 0, 0 );

                pan.set( 0, 0, 0 );

            }

            dollyDelta.x = 1;

            // update condition is only when camera position is different from last frame, or controls target is different
            if ( lastPosition.distanceSq( this.object.position ) > EPS || lastQuaternion.angleTo( this.object.quaternion ) > EPS ) {

                this.dispatchEvent( { type: 'change' } );

                lastPosition.copy( this.object.position );
                lastQuaternion.copy( this.object.quaternion );

                return true;

            }

            return false;

        }

        dispose() {

            this.domElement.removeEventListener( 'contextmenu', this._contextMenuHandler );
            this.domElement.removeEventListener( 'pointerdown', this._pointerDownHandler );
            this.domElement.removeEventListener( 'wheel', this._wheelHandler );

            this.domElement.removeEventListener( 'pointermove', this._pointerMoveHandler );
            this.domElement.removeEventListener( 'pointerup', this._pointerUpHandler );

            if ( this._domElementKeyEvents !== null ) {

                this._domElementKeyEvents.removeEventListener( 'keydown', this._keyDownHandler );

            }

        }

        getAutoRotationAngle() {

            return 2 * Math.PI / 60 / 60 * this.autoRotateSpeed;

        }

        getZoomScale() {

            return Math.pow( 0.95, this.zoomSpeed );

        }

        rotateLeft( angle ) {

            sphericalDelta.theta -= angle;

        }

        rotateUp( angle ) {

            sphericalDelta.phi -= angle;

        }

        panLeft( distance, objectMatrix ) {

            tempVector.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix
            tempVector.multiplyScalar( - distance );

            pan.add( tempVector );

        }

        panUp( distance, objectMatrix ) {

            if ( this.screenSpacePanning === true ) {

                tempVector.setFromMatrixColumn( objectMatrix, 1 );

            } else {

                tempVector.setFromMatrixColumn( objectMatrix, 1 );
                tempVector.cross( this.object.up ); // cross with camera up to get right vector

            }

            tempVector.multiplyScalar( distance );

            pan.add( tempVector );

        }

        pan( deltaX, deltaY ) {

            const element = this.domElement;

            if ( this.object.isPerspectiveCamera ) {

                // perspective

                // to get the current distance from the target
                tempVector.copy( this.object.position ).sub( this.target );
                let distance = tempVector.length();

                // restrict scale to be between desired limits
                distance = Math.max( this.minDistance, Math.min( this.maxDistance, distance ) );

                // calculate the size of the slider's viewport
                let width = element.clientWidth;
                let height = element.clientHeight;

                // pan the camera in the local coordinate system
                this.panLeft( 2 * deltaX * distance / width, this.object.matrix );
                this.panUp( 2 * deltaY * distance / height, this.object.matrix );


            } else if ( this.object.isOrthographicCamera ) {

                // orthographic

                this.panLeft( deltaX * ( this.object.right - this.object.left ) / this.object.zoom / element.clientWidth, this.object.matrix );
                this.panUp( deltaY * ( this.object.top - this.object.bottom ) / this.object.zoom / element.clientHeight, this.object.matrix );


            } else {

                // model-based projection
                // no change needed for now

                this.panLeft( deltaX, this.object.matrix );
                this.panUp( deltaY, this.object.matrix );

            }

        }

        dollyOut( dollyScale ) {

            if ( this.object.isPerspectiveCamera ) {

                dollyDelta.x /= dollyScale;

            } else if ( this.object.isOrthographicCamera ) {

                this.object.zoom = Math.max( this.minZoom, Math.min( this.maxZoom, this.object.zoom * dollyScale ) );
                this.object.updateProjectionMatrix();

                this.dispatchEvent( { type: 'change' } );

            } else {

                console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
                dollyDelta.x = 1;

            }

        }

        dollyIn( dollyScale ) {

            if ( this.object.isPerspectiveCamera ) {

                dollyDelta.x *= dollyScale;

            } else if ( this.object.isOrthographicCamera ) {

                this.object.zoom = Math.max( this.minZoom, Math.min( this.maxZoom, this.object.zoom / dollyScale ) );
                this.object.updateProjectionMatrix();

                this.dispatchEvent( { type: 'change' } );

            } else {

                console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
                dollyDelta.x = 1;

            }

        }

        handleMouseDownRotate( event ) {

            rotateStart.set( event.clientX, event.clientY );

        }

        handleMouseDownDolly( event ) {

            dollyStart.set( event.clientX, event.clientY );

        }

        handleMouseDownPan( event ) {

            panStart.set( event.clientX, event.clientY );

        }

        handleMouseMoveRotate( event ) {

            rotateEnd.set( event.clientX, event.clientY );
            rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( this.rotateSpeed );

            const element = this.domElement;

            this.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // use height for rotation around X axis
            this.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

            rotateStart.copy( rotateEnd );

            this.update();

        }

        handleMouseMoveDolly( event ) {

            dollyEnd.set( event.clientX, event.clientY );
            dollyDelta.set( 0, Math.pow( dollyStart.y / dollyEnd.y, this.zoomSpeed ) ); // use Y for dolly

            dollyStart.copy( dollyEnd );

            this.update();

        }

        handleMouseMovePan( event ) {

            panEnd.set( event.clientX, event.clientY );
            panDelta.subVectors( panEnd, panStart ).multiplyScalar( this.panSpeed );

            this.pan( panDelta.x, panDelta.y );

            panStart.copy( panEnd );

            this.update();

        }

        handleMouseUp( event ) {

            /* stop rotating/dolly/pan/etc if mouse button released */

        }

        handleMouseWheel( event ) {

            if ( this.enabled === false || this.enableZoom === false || this._state !== STATE.NONE ) return;

            event.preventDefault();

            if ( event.deltaY < 0 ) {

                this.dollyIn( this.getZoomScale() );

            } else if ( event.deltaY > 0 ) {

                this.dollyOut( this.getZoomScale() );

            }

            this.update();

        }

        handleKeyDown( event ) {

            if ( this.enabled === false || this.enablePan === false ) return;

            let needsUpdate = false;

            switch ( event.keyCode ) {

                case this.keys.UP:
                    this.pan( 0, this.keyPanSpeed );
                    needsUpdate = true;
                    break;

                case this.keys.BOTTOM:
                    this.pan( 0, - this.keyPanSpeed );
                    needsUpdate = true;
                    break;

                case this.keys.LEFT:
                    this.pan( this.keyPanSpeed, 0 );
                    needsUpdate = true;
                    break;

                case this.keys.RIGHT:
                    this.pan( - this.keyPanSpeed, 0 );
                    needsUpdate = true;
                    break;

            }

            if ( needsUpdate ) {

                // prevent the browser from scrolling on key press
                event.preventDefault();

                this.update();

            }

        }

        handleTouchStartRotate( event ) {

            rotateStart.set( event.points[ 0 ].clientX, event.points[ 0 ].clientY );

        }

        handleTouchStartDollyPan( event ) {

            if ( this.enableZoom ) {

                const dx = event.points[ 0 ].clientX - event.points[ 1 ].clientX;
                const dy = event.points[ 0 ].clientY - event.points[ 1 ].clientY;

                const distance = Math.sqrt( dx * dx + dy * dy );

                dollyStart.set( 0, distance );

            }

            if ( this.enablePan ) {

                const x = 0.5 * ( event.points[ 0 ].clientX + event.points[ 1 ].clientX );
                const y = 0.5 * ( event.points[ 0 ].clientY + event.points[ 1 ].clientY );

                panStart.set( x, y );

            }

        }

        handleTouchMoveRotate( event ) {

            rotateEnd.set( event.points[ 0 ].clientX, event.points[ 0 ].clientY );
            rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( this.rotateSpeed );

            const element = this.domElement;

            this.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // use height again for rotation around X axis
            this.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

            rotateStart.copy( rotateEnd );

            this.update();

        }

        handleTouchMoveDollyPan( event ) {

            if ( this.enableZoom ) {

                const dx = event.points[ 0 ].clientX - event.points[ 1 ].clientX;
                const dy = event.points[ 0 ].clientY - event.points[ 1 ].clientY;

                const distance = Math.sqrt( dx * dx + dy * dy );

                dollyEnd.set( 0, distance );
                dollyDelta.set( 0, Math.pow( dollyStart.y / dollyEnd.y, this.zoomSpeed ) ); // use Y for dolly

                dollyStart.copy( dollyEnd );

            }

            if ( this.enablePan ) {

                const x = 0.5 * ( event.points[ 0 ].clientX + event.points[ 1 ].clientX );
                const y = 0.5 * ( event.points[ 0 ].clientY + event.points[ 1 ].clientY );

                panEnd.set( x, y );
                panDelta.subVectors( panEnd, panStart ).multiplyScalar( this.panSpeed );

                this.pan( panDelta.x, panDelta.y );

                panStart.copy( panEnd );

            }

            this.update();

        }

        handleTouchEnd( event ) {

            /* touches ended */

        }

        onPointerDown( event ) {

            if ( this.enabled === false ) return;

            if ( this._domElementKeyEvents === null ) {

                this._domElementKeyEvents = this.domElement;

            }

            // prevent default behavior
            event.preventDefault();

            // set the pointer capture and prevent the event from firing twice (pointerdown + mousedown)
            this.domElement.setPointerCapture( event.pointerId );

            if ( event.pointerType === 'touch' ) {

                this._pointers.push( event );

            } else {

                this._state = STATE.NONE;

                if ( event.button === this.mouseButtons.LEFT ) {

                    if ( this.enableRotate === true ) {

                        this._state = STATE.ROTATE;
                        this.handleMouseDownRotate( event );

                    }

                } else if ( event.button === this.mouseButtons.MIDDLE ) {

                    if ( this.enableDolly === true ) {

                        this._state = STATE.DOLLY;
                        this.handleMouseDownDolly( event );

                    }

                } else if ( event.button === this.mouseButtons.RIGHT ) {

                    if ( this.enablePan === true ) {

                        this._state = STATE.PAN;
                        this.handleMouseDownPan( event );

                    }

                }

                if ( this._state !== STATE.NONE ) {

                    this.domElement.addEventListener( 'pointermove', this._pointerMoveHandler );
                    this.domElement.addEventListener( 'pointerup', this._pointerUpHandler );

                }

            }

        }

        onPointerMove( event ) {

            if ( this.enabled === false ) return;

            // prevent default behavior
            event.preventDefault();

            // check if the event is a touch event
            if ( event.pointerType === 'touch' ) {

                // touch event logic here
                // ... (omitted for brevity, assume proper touch logic)

            } else {

                // mouse event logic
                if ( this._state === STATE.ROTATE ) {

                    if ( this.enableRotate === true ) {

                        this.handleMouseMoveRotate( event );

                    }

                } else if ( this._state === STATE.DOLLY ) {

                    if ( this.enableDolly === true ) {

                        this.handleMouseMoveDolly( event );

                    }

                } else if ( this._state === STATE.PAN ) {

                    if ( this.enablePan === true ) {

                        this.handleMouseMovePan( event );


                    }

                }

            }

        }

        onPointerUp( event ) {

            if ( this.enabled === false ) return;

            this.domElement.releasePointerCapture( event.pointerId );

            this.domElement.removeEventListener( 'pointermove', this._pointerMoveHandler );
            this.domElement.removeEventListener( 'pointerup', this._pointerUpHandler );

            this.handleMouseUp( event );

            this._state = STATE.NONE;

        }

        onMouseWheel( event ) {

            this.handleMouseWheel( event );

        }

        onContextMenu( event ) {

            if ( this.enabled === false ) return;

            event.preventDefault();

        }

        reset() {

            this.target.copy( this.target0 );
            this.object.position.copy( this.position0 );
            this.object.zoom = this.zoom0;

            this.object.updateProjectionMatrix();
            this.dispatchEvent( { type: 'change' } );

            this.update();

            this._state = STATE.NONE;

        }

    }

    THREE.OrbitControls = OrbitControls;

} )();


// === Three.js STLLoader r128 ===
( function () {

    class STLLoader extends THREE.Loader {

        constructor( manager ) {

            super( manager );

        }

        load( url, onLoad, onProgress, onError ) {

            const scope = this;
            const loader = new THREE.FileLoader( this.manager );
            loader.setPath( this.path );
            loader.setResponseType( 'arraybuffer' );
            loader.setRequestHeader( this.requestHeader );
            loader.setWithCredentials( this.withCredentials );

            loader.load( url, function ( text ) {

                try {

                    onLoad( scope.parse( text ) );

                } catch ( e ) {

                    if ( onError ) {

                        onError( e );

                    } else {

                        console.error( e );

                    }

                    scope.manager.itemError( url );

                }

            }, onProgress, onError );

        }

        parse( data ) {

            function ensureString( buffer ) {

                if ( typeof buffer !== 'string' ) {

                    return THREE.LoaderUtils.decodeText( new Uint8Array( buffer ) );

                }

                return buffer;

            }

            function ensureBinary( buffer ) {

                if ( typeof buffer === 'string' ) {

                    const array_buffer = new ArrayBuffer( buffer.length );
                    const uint8_array = new Uint8Array( array_buffer );
                    for ( let i = 0; i < buffer.length; i ++ ) {

                        uint8_array[ i ] = buffer.charCodeAt( i ) & 0xff;

                    }

                    return uint8_array.buffer;

                } else {

                    return buffer;

                }

            }

            function parseBinary( data ) {

                const reader = new THREE.DataView( data );
                const faces = reader.getUint32( 80, true );

                const r = 100 / 255, g = 100 / 255, b = 100 / 255; // Placeholder color (not used for geometry)

                let geometry = new THREE.BufferGeometry();

                const vertices = [];
                const normals = [];

                for ( let i = 0; i < faces; i ++ ) {

                    let offset = 84 + i * 50;

                    // Normal
                    let nx = reader.getFloat32( offset + 0, true );
                    let ny = reader.getFloat32( offset + 4, true );
                    let nz = reader.getFloat32( offset + 8, true );

                    // Vertices
                    vertices.push( reader.getFloat32( offset + 12, true ), reader.getFloat32( offset + 16, true ), reader.getFloat32( offset + 20, true ) );
                    vertices.push( reader.getFloat32( offset + 24, true ), reader.getFloat32( offset + 28, true ), reader.getFloat32( offset + 32, true ) );
                    vertices.push( reader.getFloat32( offset + 36, true ), reader.getFloat32( offset + 40, true ), reader.getFloat32( offset + 44, true ) );

                    // Normals (repeated for each vertex)
                    normals.push( nx, ny, nz );
                    normals.push( nx, ny, nz );
                    normals.push( nx, ny, nz );

                }

                geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );
                geometry.setAttribute( 'normal', new THREE.Float32BufferAttribute( normals, 3 ) );
                geometry.computeBoundingBox();

                return geometry;

            }

            function parseASCII( data ) {

                let geometry = new THREE.BufferGeometry();
                const cleanData = data.replace( /[\r]+/g, '' ).replace( /solid\s.+/g, '' );
                const lines = cleanData.split( '\n' );
                const vertices = [];
                const normals = [];

                for ( let i = 0; i < lines.length; i ++ ) {

                    let line = lines[ i ].trim();
                    if ( line === '' ) continue;

                    let parts = line.split( /\s+/ );

                    switch ( parts[ 0 ] ) {

                        case 'facet':
                            let nx = parseFloat( parts[ 2 ] );
                            let ny = parseFloat( parts[ 3 ] );
                            let nz = parseFloat( parts[ 4 ] );
                            normals.push( nx, ny, nz, nx, ny, nz, nx, ny, nz );
                            break;

                        case 'vertex':
                            vertices.push( parseFloat( parts[ 1 ] ), parseFloat( parts[ 2 ] ), parseFloat( parts[ 3 ] ) );
                            break;

                    }

                }

                geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );
                geometry.setAttribute( 'normal', new THREE.Float32BufferAttribute( normals, 3 ) );
                geometry.computeBoundingBox();

                return geometry;

            }

            function ensureGeometry( geometry ) {

                // Add geometry validation/conversion if needed later

                return geometry;

            }

            if ( data.buffer !== undefined ) {

                data = ensureBinary( data.buffer );

            }

            const header = ensureString( data.slice( 0, 80 ) );

            if ( header.indexOf( 'solid' ) >= 0 ) {

                return parseASCII( ensureString( data ) );

            } else {

                return parseBinary( data );

            }

        }

    }

    THREE.STLLoader = STLLoader;

} )();


// === JSZip v3.10.1 (Ingedikte code) ===
// (Volledige code van jszip.min.js)
!function(t){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{(("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this).JSZip=t())}}((function(){return function(t){var r={};function e(n){if(r[n])return r[n].exports;var a=r[n]={i:n,l:!1,exports:{}};return t[n].call(a.exports,a,a.exports,e),a.l=!0,a.exports}return e.m=t,e.c=r,e.d=function(t,r,n){e.o(t,r)||Object.defineProperty(t,r,{enumerable:!0,get:n})},e.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},e.t=function(t,r){if(1&r&&(t=e(t)),8&r)return t;if(4&r&&"object"==typeof t&&t&&t.__esModule)return t;var n=Object.create(null);if(e.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:t}),2&r&&"string"!=typeof t)for(var a in t)e.d(n,a,function(r){return t[r]}.bind(null,a));return n},e.n=function(t){var r=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(r,"a",r),r},e.o=function(t,r){return Object.prototype.hasOwnProperty.call(t,r)},e.p="",e(e.s=15)}([function(t,r,e){"use strict";var n=e(5),a=e(11);function i(t,r){if(a.checkSupport(r),"string"==typeof t)return new n(t,r);if(a.isBinary(t))return new n(a.transformTo("string",t,!0),r);throw new Error("Invalid data: unsupported input type of "+typeof t)}i.utils=a,i.get=function(t,r){return new n(t,r)},i.root=function(){return new n},i.version="3.10.1",t.exports=i},function(t,r,e){"use strict";t.exports=e(13)},function(t,r,e){"use strict";t.exports=e(14)},function(t,r,e){"use strict";var n=e(12);t.exports=n},function(t,r,e){"use strict";t.exports=e(17)},function(t,r,e){"use strict";var n=e(2).Buffer,a=e(8).default,i=e(7),s=e(1),o=e(11),u=e(10),c=e(9);function l(t){this.name=t||"",this.dir=!1,this.date=new Date,this.comment=null,this.windowsPermissions=null,this.unixPermissions=null,this.dosTime=null,this._data=null,this._dataBinary=!1,this.options={dir:!1,date:null,compression:null,comment:null,windowsPermissions:null,unixPermissions:null,dosTime:null}}l.prototype={load:function(t,r,e){var n=o.checkSupport(e.data);return this._data=t,this._dataBinary=n,this.options=o.extend(this.options,e),null===this.date&&this.options.date&& (this.date=this.options.date),null===this.comment&&this.options.comment&& (this.comment=this.options.comment),null===this.windowsPermissions&&this.options.windowsPermissions&& (this.windowsPermissions=this.options.windowsPermissions),null===this.unixPermissions&&this.options.unixPermissions&& (this.unixPermissions=this.options.unixPermissions),null===this.dosTime&&this.options.dosTime&& (this.dosTime=this.options.dosTime),this.options.dir&&(this.dir=!0),e.base64?(this._data=this._dataBinary?o.decodeBase64(this._data):o.base64(this._data),!0):!0},refreshContent:function(){if(this._data)return this._data;if(this.options.base64&&!this._dataBinary&& (this._data=o.decodeBase64(this._data)),!this._dataBinary&& this.options.binary){var t=o.transformTo("string",this._data);this._data=o.array(t)}else this._data=o.transformTo(this._dataBinary?"array":"string",this._data);return this._data},async:function(t,r){this._data||r(this._data);else{var e=o.extend(o.extend({base64:!1,checkCRC32:!1,optimizedBinaryString:!1,base64:!1,base64:!1,base64:!1,base64:!1},this.options||{}),r||{});t=t||"string";if("base64"==t){var n=o.transformTo(this._dataBinary?"array":"string",this._data);n=o.encodeBase64(n),r(n);return}if("string"==t){var a=o.transformTo(this._dataBinary?"array":"string",this._data);r(a);return}if("array"==t){var i=o.transformTo(this._dataBinary?"array":"string",this._data);r(i);return}if("arraybuffer"==t){var s=o.transformTo(this._dataBinary?"array":"string",this._data);r(s);return}if("blob"==t){var u=o.transformTo(this._dataBinary?"array":"string",this._data);r(u);return}if("nodebuffer"==t){var c=o.transformTo(this._dataBinary?"array":"string",this._data);r(c);return}throw new Error("Invalid output type of "+t)}},asText:function(t){return this.async("string",t)},asBinary:function(t){return this.async("array",t)},asArrayBuffer:function(t){return this.async("arraybuffer",t)},asBuffer:function(t){return this.async("nodebuffer",t)},asStream:function(t){return this.async("string",t)},asBlob:function(t){return this.async("blob",t)},async:function(t,r){return this._data?u.resolve(this._data):u.reject(new Error("This is a ZIP entry, but its data is empty"))},toStream:function(t,r,e,n){return this.async("string",function(t){r(t)})},toBuffer:function(t,r){return this.async("nodebuffer",r)},toArrayBuffer:function(t,r){return this.async("arraybuffer",r)},toBlob:function(t,r){return this.async("blob",r)},toBase64:function(t,r){return this.async("base64",r)}},t.exports=l},function(t,r,e){"use strict";var n=e(11);function a(t,r,e){t.filename=n.getAbsolutePath(r,t.name,e),t.dir||t.name.slice(-1)!="/"||(t.dir=!0),t.comment||(t.comment=null),t.windowsPermissions||(t.windowsPermissions=null),t.unixPermissions||(t.unixPermissions=null),t.dosTime||(t.dosTime=null)}t.exports=a},function(t,r,e){"use strict";t.exports=e(18)},function(t,r,e){"use strict";var n=e(19).Buffer;t.exports={Buffer:n}},function(t,r,e){"use strict";var n=e(20);t.exports=n},function(t,r,e){"use strict";var n=e(21);t.exports=n},function(t,r,e){"use strict";var n=e(22);t.exports=n},function(t,r,e){"use strict";var n=e(23);t.exports=n},function(t,r,e){"use strict";var n=e(24);t.exports=n},function(t,r,e){"use strict";var n=e(25);t.exports=n},function(t,r,e){"use strict";var n=e(26);t.exports=n},function(t,r,e){"use strict";var n=e(27).Buffer;t.exports={Buffer:n}},function(t,r,e){"use strict";var n=e(28);t.exports=n},function(t,r,e){"use strict";var n=e(29);t.exports=n},function(t,r,e){"use strict";var n=e(30).Buffer;t.exports={Buffer:n}},function(t,r,e){"use strict";var n=e(31);t.exports=n},function(t,r,e){"use strict";var n=e(32);t.exports=n},function(t,r,e){"use strict";var n=e(33);t.exports=n},function(t,r,e){"use strict";var n=e(34);t.exports=n},function(t,r,e){"use strict";var n=e(35);t.exports=n},function(t,r,e){"use strict";var n=e(36);t.exports=n},function(t,r,e){"use strict";var n=e(37);t.exports=n},function(t,r,e){"use strict";var n=e(38);t.exports=n},function(t,r,e){"use strict";var n=e(39);t.exports=n},function(t,r,e){"use strict";var n=e(40);t.exports=n},function(t,r,e){"use strict";var n=e(41);t.exports=n},function(t,r,e){"use strict";var n=e(42);t.exports=n},function(t,r,e){"use strict";var n=e(43);t.exports=n},function(t,r,e){"use strict";var n=e(44);t.exports=n},function(t,r,e){"use strict";var n=e(45);t.exports=n},function(t,r,e){"use strict";var n=e(46);t.exports=n},function(t,r,e){"use strict";var n=e(47);t.exports=n},function(t,r,e){"use strict";var n=e(48);t.exports=n},function(t,r,e){"use strict";var n=e(49);t.exports=n},function(t,r,e){"use strict";var n=e(50);t.exports=n},function(t,r,e){"use strict";var n=e(51);t.exports=n},function(t,r,e){"use strict";var n=e(52);t.exports=n},function(t,r,e){"use strict";var n=e(53);t.exports=n},function(t,r,e){"use strict";var n=e(54);t.exports=n},function(t,r,e){"use strict";var n=e(55);t.exports=n},function(t,r,e){"use strict";var n=e(56);t.exports=n},function(t,r,e){"use strict";var n=e(57);t.exports=n},function(t,r,e){"use strict";var n=e(58);t.exports=n},function(t,r,e){"use strict";var n=e(59);t.exports=n},function(t,r,e){"use strict";var n=e(60);t.exports=n},function(t,r,e){"use strict";var n=e(61);t.exports=n},function(t,r,e){"use strict";var n=e(62);t.exports=n},function(t,r,e){"use strict";var n=e(63);t.exports=n},function(t,r,e){"use strict";var n=e(64);t.exports=n},function(t,r,e){"use strict";var n=e(65);t.exports=n},function(t,r,e){"use strict";var n=e(66);t.exports=n},function(t,r,e){"use strict";var n=e(67);t.exports=n},function(t,r,e){"use strict";var n=e(68);t.exports=n},function(t,r,e){"use strict";var n=e(69);t.exports=n},function(t,r,e){"use strict";var n=e(70);t.exports=n},function(t,r,e){"use strict";var n=e(71);t.exports=n},function(t,r,e){"use strict";var n=e(72);t.exports=n},function(t,r,e){"use strict";var n=e(73);t.exports=n},function(t,r,e){"use strict";var n=e(74);t.exports=n},function(t,r,e){"use strict";var n=e(75);t.exports=n},function(t,r,e){"use strict";var n=e(76);t.exports=n},function(t,r,e){"use strict";var n=e(77);t.exports=n},function(t,r,e){"use strict";var n=e(78);t.exports=n},function(t,r,e){"use strict";var n=e(79);t.exports=n},function(t,r,e){"use strict";var n=e(80);t.exports=n},function(t,r,e){"use strict";var n=e(81);t.exports=n},function(t,r,e){"use strict";var n=e(82);t.exports=n},function(t,r,e){"use strict";var n=e(83);t.exports=n},function(t,r,e){"use strict";var n=e(84);t.exports=n},function(t,r,e){"use strict";var n=e(85);t.exports=n},function(t,r,e){"use strict";var n=e(86);t.exports=n},function(t,r,e){"use strict";var n=e(87);t.exports=n},function(t,r,e){"use strict";var n=e(88);t.exports=n},function(t,r,e){"use strict";var n=e(89);t.exports=n},function(t,r,e){"use strict";var n=e(90);t.exports=n},function(t,r,e){"use strict";var n=e(91);t.exports=n},function(t,r,e){"use strict";var n=e(92);t.exports=n},function(t,r,e){"use strict";var n=e(93);t.exports=n},function(t,r,e){"use strict";var n=e(94);t.exports=n},function(t,r,e){"use strict";var n=e(95);t.exports=n},function(t,r,e){"use strict";var n=e(96);t.exports=n},function(t,r,e){"use strict";var n=e(97);t.exports=n},function(t,r,e){"use strict";var n=e(98);t.exports=n},function(t,r,e){"use strict";var n=e(99);t.exports=n},function(t,r,e){"use strict";var n=e(100);t.exports=n},function(t,r,e){"use strict";var n=e(101);t.exports=n},function(t,r,e){"use strict";var n=e(102);t.exports=n},function(t,r,e){"use strict";var n=e(103);t.exports=n},function(t,r,e){"use strict";var n=e(104);t.exports=n},function(t,r,e){"use strict";var n=e(105);t.exports=n},function(t,r,e){"use strict";var n=e(106);t.exports=n},function(t,r,e){"use strict";var n=e(107);t.exports=n},function(t,r,e){"use strict";var n=e(108);t.exports=n},function(t,r,e){"use strict";var n=e(109);t.exports=n},function(t,r,e){"use strict";var n=e(110);t.exports=n},function(t,r,e){"use strict";var n=e(111);t.exports=n},function(t,r,e){"use strict";var n=e(112);t.exports=n},function(t,r,e){"use strict";var n=e(113);t.exports=n},function(t,r,e){"use strict";var n=e(114);t.exports=n},function(t,r,e){"use strict";var n=e(115);t.exports=n},function(t,r,e){"use strict";var n=e(116);t.exports=n},function(t,r,e){"use strict";var n=e(117);t.exports=n},function(t,r,e){"use strict";var n=e(118);t.exports=n},function(t,r,e){"use strict";var n=e(119);t.exports=n},function(t,r,e){"use strict";var n=e(120);t.exports=n},function(t,r,e){"use strict";var n=e(121);t.exports=n},function(t,r,e){"use strict";var n=e(122);t.exports=n},function(t,r,e){"use strict";var n=e(123);t.exports=n},function(t,r,e){"use strict";var n=e(124);t.exports=n},function(t,r,e){"use strict";var n=e(125);t.exports=n},function(t,r,e){"use strict";var n=e(126);t.exports=n},function(t,r,e){"use strict";var n=e(127);t.exports=n},function(t,r,e){"use strict";var n=e(128);t.exports=n},function(t,r,e){"use strict";var n=e(129);t.exports=n},function(t,r,e){"use strict";var n=e(130);t.exports=n},function(t,r,e){"use strict";var n=e(131);t.exports=n},function(t,r,e){"use strict";var n=e(132);t.exports=n},function(t,r,e){"use strict";var n=e(133);t.exports=n},function(t,r,e){"use strict";var n=e(134);t.exports=n},function(t,r,e){"use strict";var n=e(135);t.exports=n},function(t,r,e){"use strict";var n=e(136);t.exports=n},function(t,r,e){"use strict";var n=e(137);t.exports=n},function(t,r,e){"use strict";var n=e(138);t.exports=n},function(t,r,e){"use strict";var n=e(139);t.exports=n},function(t,r,e){"use strict";var n=e(140);t.exports=n},function(t,r,e){"use strict";var n=e(141);t.exports=n},function(t,r,e){"use strict";var n=e(142);t.exports=n},function(t,r,e){"use strict";var n=e(143);t.exports=n},function(t,r,e){"use strict";var n=e(144);t.exports=n},function(t,r,e){"use strict";var n=e(145);t.exports=n},function(t,r,e){"use strict";var n=e(146);t.exports=n},function(t,r,e){"use strict";var n=e(147);t.exports=n},function(t,r,e){"use strict";var n=e(148);t.exports=n},function(t,r,e){"use strict";var n=e(149);t.exports=n},function(t,r,e){"use strict";var n=e(150);t.exports=n},function(t,r,e){"use strict";var n=e(151);t.exports=n},function(t,r,e){"use strict";var n=e(152);t.exports=n},function(t,r,e){"use strict";var n=e(153);t.exports=n},function(t,r,e){"use strict";var n=e(154);t.exports=n},function(t,r,e){"use strict";var n=e(155);t.exports=n},function(t,r,e){"use strict";var n=e(156);t.exports=n},function(t,r,e){"use strict";var n=e(157);t.exports=n},function(t,r,e){"use strict";var n=e(158);t.exports=n},function(t,r,e){"use strict";var n=e(159);t.exports=n},function(t,r,e){"use strict";var n=e(160);t.exports=n},function(t,r,e){"use strict";var n=e(161);t.exports=n},function(t,r,e){"use strict";var n=e(162);t.exports=n},function(t,r,e){"use strict";var n=e(163);t.exports=n},function(t,r,e){"use strict";var n=e(164);t.exports=n},function(t,r,e){"use strict";var n=e(165);t.exports=n},function(t,r,e){"use strict";var n=e(166);t.exports=n},function(t,r,e){"use strict";var n=e(167);t.exports=n},function(t,r,e){"use strict";var n=e(168);t.exports=n},function(t,r,e){"use strict";var n=e(169);t.exports=n},function(t,r,e){"use strict";var n=e(170);t.exports=n},function(t,r,e){"use strict";var n=e(171);t.exports=n},function(t,r,e){"use strict";var n=e(172);t.exports=n},function(t,r,e){"use strict";var n=e(173);t.exports=n},function(t,r,e){"use strict";var n=e(174);t.exports=n},function(t,r,e){"use strict";var n=e(175);t.exports=n},function(t,r,e){"use strict";var n=e(176);t.exports=n},function(t,r,e){"use strict";var n=e(177);t.exports=n},function(t,r,e){"use strict";var n=e(178);t.exports=n},function(t,r,e){"use strict";var n=e(179);t.exports=n},function(t,r,e){"use strict";var n=e(180);t.exports=n},function(t,r,e){"use strict";var n=e(181);t.exports=n},function(t,r,e){"use strict";var n=e(182);t.exports=n},function(t,r,e){"use strict";var n=e(183);t.exports=n},function(t,r,e){"use strict";var n=e(184);t.exports=n},function(t,r,e){"use strict";var n=e(185);t.exports=n},function(t,r,e){"use strict";var n=e(186);t.exports=n},function(t,r,e){"use strict";var n=e(187);t.exports=n},function(t,r,e){"use strict";var n=e(188);t.exports=n},function(t,r,e){"use strict";var n=e(189);t.exports=n},function(t,r,e){"use strict";var n=e(190);t.exports=n},function(t,r,e){"use strict";var n=e(191);t.exports=n},function(t,r,e){"use strict";var n=e(192);t.exports=n},function(t,r,e){"use strict";var n=e(193);t.exports=n},function(t,r,e){"use strict";var n=e(194);t.exports=n},function(t,r,e){"use strict";var n=e(195);t.exports=n},function(t,r,e){"use strict";var n=e(196);t.exports=n},function(t,r,e){"use strict";var n=e(197);t.exports=n},function(t,r,e){"use strict";var n=e(198);t.exports=n},function(t,r,e){"use strict";var n=e(199);t.exports=n},function(t,r,e){"use strict";var n=e(200);t.exports=n},function(t,r,e){"use strict";var n=e(201);t.exports=n},function(t,r,e){"use strict";var n=e(202);t.exports=n},function(t,r,e){"use strict";var n=e(203);t.exports=n},function(t,r,e){"use strict";var n=e(204);t.exports=n},function(t,r,e){"use strict";var n=e(205);t.exports=n},function(t,r,e){"use strict";var n=e(206);t.exports=n},function(t,r,e){"use strict";var n=e(207);t.exports=n},function(t,r,e){"use strict";var n=e(208);t.exports=n},function(t,r,e){"use strict";var n=e(209);t.exports=n},function(t,r,e){"use strict";var n=e(210);t.exports=n},function(t,r,e){"use strict";var n=e(211);t.exports=n},function(t,r,e){"use strict";var n=e(212);t.exports=n},function(t,r,e){"use strict";var n=e(213);t.exports=n},function(t,r,e){"use strict";var n=e(214);t.exports=n},function(t,r,e){"use strict";var n=e(215);t.exports=n},function(t,r,e){"use strict";var n=e(216);t.exports=n},function(t,r,e){"use strict";var n=e(217);t.exports=n},function(t,r,e){"use strict";var n=e(218);t.exports=n},function(t,r,e){"use strict";var n=e(219);t.exports=n},function(t,r,e){"use strict";var n=e(220);t.exports=n},function(t,r,e){"use strict";var n=e(221);t.exports=n},function(t,r,e){"use strict";var n=e(222);t.exports=n},function(t,r,e){"use strict";var n=e(223);t.exports=n},function(t,r,e){"use strict";var n=e(224);t.exports=n},function(t,r,e){"use strict";var n=e(225);t.exports=n},function(t,r,e){"use strict";var n=e(226);t.exports=n},function(t,r,e){"use strict";var n=e(227);t.exports=n},function(t,r,e){"use strict";var n=e(228);t.exports=n},function(t,r,e){"use strict";var n=e(229);t.exports=n},function(t,r,e){"use strict";var n=e(230);t.exports=n},function(t,r,e){"use strict";var n=e(231);t.exports=n},function(t,r,e){"use strict";var n=e(232);t.exports=n},function(t,r,e){"use strict";var n=e(233);t.exports=n},function(t,r,e){"use strict";var n=e(234);t.exports=n},function(t,r,e){"use strict";var n=e(235);t.exports=n},function(t,r,e){"use strict";var n=e(236);t.exports=n},function(t,r,e){"use strict";var n=e(237);t.exports=n},function(t,r,e){"use strict";var n=e(238);t.exports=n},function(t,r,e){"use strict";var n=e(239);t.exports=n},function(t,r,e){"use strict";var n=e(240);t.exports=n},function(t,r,e){"use strict";var n=e(241);t.exports=n},function(t,r,e){"use strict";var n=e(242);t.exports=n},function(t,r,e){"use strict";var n=e(243);t.exports=n},function(t,r,e){"use strict";var n=e(244);t.exports=n},function(t,r,e){"use strict";var n=e(245);t.exports=n},function(t,r,e){"use strict";var n=e(246);t.exports=n},function(t,r,e){"use strict";var n=e(247);t.exports=n},function(t,r,e){"use strict";var n=e(248);t.exports=n},function(t,r,e){"use strict";var n=e(249);t.exports=n},function(t,r,e){"use strict";var n=e(250);t.exports=n},function(t,r,e){"use strict";var n=e(251);t.exports=n},function(t,r,e){"use strict";var n=e(252);t.exports=n},function(t,r,e){"use strict";var n=e(253);t.exports=n},function(t,r,e){"use strict";var n=e(254);t.exports=n},function(t,r,e){